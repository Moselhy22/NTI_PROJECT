# include <Arduino.h>
# include <vector>
# include <cmath>

// Include TensorFlow Lite Micro library
# include <TensorFlowLite.h>
# include <tensorflow/lite/micro/all_ops_resolver.h> // Or micro_mutable_op_resolver.h for memory
# include <tensorflow/lite/micro/micro_error_reporter.h>
# include <tensorflow/lite/micro/micro_interpreter.h>
# include <tensorflow/lite/micro/system_setup.h>
# include <tensorflow/lite/schema/schema_generated.h>

// Include the model data generated by xxd
// Make sure to generate this file using: xxd -i medical_wearable_model.tflite > model_data.h
# include "model_data.h"

// ============================================================================
// GLOBAL TFLITE OBJECTS
// ============================================================================

namespace {
  tflite::ErrorReporter* error_reporter = nullptr;
  const tflite::Model* model = nullptr;
  tflite::MicroInterpreter* interpreter = nullptr;
  TfLiteTensor* input_tensor = nullptr;
  TfLiteTensor* output_tensor = nullptr;

  // An area of memory to use for input, output, and intermediate arrays.
  // The size needs to be larger than what you expect to use. It can be determined
  // by experimenting with your model and the MicroInterpreter's Get==BytesUsed() method.
  // You might need to adjust this value based on your specific TFLite model and ops.
  static const int kTensorArenaSize = 10 * 1024; // Increased from 40KB as suggested in previous notebook (40*1024=40960 bytes)
  uint8_t tensor_arena[kTensorArenaSize];
}

// ============================================================================
// HARDCODED SCALER PARAMETERS & FEATURE SELECTION (from Python) 
// ============================================================================

// --- Initial Scaler for Raw Sensor Inputs (from scaler.pkl) ---
// Order: accel_x, accel_y, accel_z, accel_magnitude, heart_rate, temperature
const float INITIAL_SCALER_MEAN[] = {0.03617035f, -0.02986360f, 5.57758738f, 13.0605690f, 87.9404196f, 37.1417882f};
const float INITIAL_SCALER_STD[] = {7.07137325f, 5.33064643f, 10.6003614f, 7.16238373f, 25.42617794f, 0.89317415f};

// --- Final Scaler for Combined Features (from new_feature_scaler.pkl) ---
const float NEW_FEATURE_SCALER_MEAN[] = {
    0.00441728f, 0.00081591f, -0.00183049f, 0.00120713f, 0.00324007f, -0.00004644f,
    3.01678627f, 1.76475258f, 3.79162773f, 1.23500000f, 0.25105354f, 0.34174675f,
    0.11633333f, 0.07933333f, 0.11033333f, 0.08733333f, 0.62966667f,
    3283.14215771f, 0.15083351f, 3.04987802f, 0.62349660f
};

const float NEW_FEATURE_SCALER_STD[] = {
    1.00873545f, 0.99877112f, 1.00083554f, 1.00508368f, 1.00088993f, 1.00669755f,
    6.47792078f, 3.18978113f, 6.93786534f, 0.63227763f, 0.28680718f, 0.89915623f,
    0.32062422f, 0.27025831f, 0.31330479f, 0.28232290f, 0.48289394f,
    1012.41721456f, 0.07667262f, 0.85844745f, 0.62702483f
};

// --- Feature Selection Indices (from selected_features.pkl) ---
// Indices of the 15 selected features in the 21 combined features list.
// The order is critical and must match `selected_features.pkl`.
const int SELECTED_FEATURE_INDICES[] = {20, 4, 17, 6, 7, 10, 19, 3, 8, 2, 11, 18, 16, 5, 9};

// Number of features the TFLite model expects
const int TFLITE_INPUT_SIZE = 15;
const int COMBINED_FEATURES_SIZE = 21;

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Function to apply scaling for a single feature (Z-score normalization)
float scale_feature(float value, float mean, float std) {
    if (std == 0.0f) return 0.0f; // Avoid division by zero
    return (value - mean) / std;
}

// Function to generate medical-specific engineered features in C++
// This function returns the 21 combined features, which are a mix of initially scaled raw inputs
// and newly engineered features based on raw or initially scaled values.
std::vector<float> create_medical_features_cpp(
    float raw_accel_x,
    float raw_accel_y,
    float raw_accel_z,
    float raw_heart_rate,
    float raw_temperature) {

    // 1. Calculate unscaled accel_magnitude (using raw inputs)
    float unscaled_accel_magnitude = std::sqrt(
        raw_accel_x * raw_accel_x +
        raw_accel_y * raw_accel_y +
        raw_accel_z * raw_accel_z
    );

    // 2. Scale the original features (accel_x, accel_y, accel_z, accel_magnitude, heart_rate, temperature)
    // These correspond to df_scaled in the Python implementation and will be part of the 21 combined features.
    float scaled_accel_x = scale_feature(raw_accel_x, INITIAL_SCALER_MEAN[0], INITIAL_SCALER_STD[0]);
    float scaled_accel_y = scale_feature(raw_accel_y, INITIAL_SCALER_MEAN[1], INITIAL_SCALER_STD[1]);
    float scaled_accel_z = scale_feature(raw_accel_z, INITIAL_SCALER_MEAN[2], INITIAL_SCALER_STD[2]);
    float scaled_accel_magnitude = scale_feature(unscaled_accel_magnitude, INITIAL_SCALER_MEAN[3], INITIAL_SCALER_STD[3]);
    float scaled_heart_rate = scale_feature(raw_heart_rate, INITIAL_SCALER_MEAN[4], INITIAL_SCALER_STD[4]);
    float scaled_temperature = scale_feature(raw_temperature, INITIAL_SCALER_MEAN[5], INITIAL_SCALER_STD[5]);

    std::vector<float> combined_features_vec; // Will hold all 21 features
    combined_features_vec.reserve(COMBINED_FEATURES_SIZE);

    // Add initially scaled original features
    combined_features_vec.push_back(scaled_accel_x);
    combined_features_vec.push_back(scaled_accel_y);
    combined_features_vec.push_back(scaled_accel_z);
    combined_features_vec.push_back(scaled_accel_magnitude);
    combined_features_vec.push_back(scaled_heart_rate);
    combined_features_vec.push_back(scaled_temperature);

    // 1. ACCELERATION FEATURES (based on scaled_accel_x,y,z)
    // accel_energy
    combined_features_vec.push_back(scaled_accel_x * scaled_accel_x + scaled_accel_y * scaled_accel_y + scaled_accel_z * scaled_accel_z);

    // accel_vertical_ratio
    float accel_horizontal_scaled = std::sqrt(scaled_accel_x * scaled_accel_x + scaled_accel_y * scaled_accel_y);
    combined_features_vec.push_back(scaled_accel_z / (accel_horizontal_scaled + 0.001f));

    // accel_deviation_gravity (uses unscaled magnitude)
    combined_features_vec.push_back(std::abs(unscaled_accel_magnitude - 9.8f));

    // 2. HEART RATE FEATURES (uses unscaled heart_rate)
    // hr_zone
    float hr_zone_val;
    if (raw_heart_rate <= 60.0f) hr_zone_val = 0.0f;
    else if (raw_heart_rate <= 100.0f) hr_zone_val = 1.0f;
    else if (raw_heart_rate <= 140.0f) hr_zone_val = 2.0f;
    else hr_zone_val = 3.0f;
    combined_features_vec.push_back(hr_zone_val);

    // hr_severity
    combined_features_vec.push_back(std::abs(raw_heart_rate - 75.0f) / 75.0f);

    // 3. TEMPERATURE FEATURES (uses unscaled temperature)
    // temp_deviation
    combined_features_vec.push_back(raw_temperature - 36.8f);

    // temp_fever
    combined_features_vec.push_back((raw_temperature > 38.0f) ? 1.0f : 0.0f);

    // 4. COMBINED MEDICAL INDICATORS (uses unscaled heart_rate, temperature, accel_magnitude)
    // fall_indicator
    combined_features_vec.push_back(
        (unscaled_accel_magnitude > 15.0f &&
         raw_heart_rate < 100.0f &&
         raw_temperature < 38.0f) ? 1.0f : 0.0f
    );

    // seizure_indicator
    combined_features_vec.push_back(
        (unscaled_accel_magnitude > 10.0f &&
         raw_heart_rate > 120.0f) ? 1.0f : 0.0f
    );

    // emergency_indicator
    combined_features_vec.push_back(
        (raw_temperature > 38.5f &&
         raw_heart_rate > 110.0f &&
         unscaled_accel_magnitude < 12.0f) ? 1.0f : 0.0f
    );

    // normal_indicator
    combined_features_vec.push_back(
        (raw_heart_rate >= 60.0f && raw_heart_rate <= 100.0f &&
         raw_temperature >= 36.0f && raw_temperature <= 37.5f &&
         unscaled_accel_magnitude < 15.0f) ? 1.0f : 0.0f
    );

    // 5. INTERACTION FEATURES (uses unscaled heart_rate, temperature, accel_magnitude)
    // hr_temp_product
    combined_features_vec.push_back(raw_heart_rate * raw_temperature);

    // movement_hr_ratio
    combined_features_vec.push_back(unscaled_accel_magnitude / (raw_heart_rate + 1.0f));

    // temp_movement_ratio
    combined_features_vec.push_back(raw_temperature / (unscaled_accel_magnitude + 1.0f));

    // 6. STABILITY INDICATORS (uses engineered features based on unscaled values)
    // physiological_stress - calculate components directly for C++
    float hr_severity = std::abs(raw_heart_rate - 75.0f) / 75.0f; // Recalculated for this feature
    float temp_deviation = raw_temperature - 36.8f; // Recalculated for this feature
    float accel_deviation_gravity = std::abs(unscaled_accel_magnitude - 9.8f); // Recalculated for this feature

    combined_features_vec.push_back(
        hr_severity +
        std::abs(temp_deviation) / 3.0f +
        accel_deviation_gravity / 20.0f
    );

    return combined_features_vec;
}

// Function to apply final scaling and select features for the TFLite model
std::vector<float> apply_final_scaling_and_selection_cpp(const std::vector<float>& combined_features) {
    if (combined_features.size() != COMBINED_FEATURES_SIZE) {
        TF_LITE_REPORT_ERROR(error_reporter, "Error: Expected %d combined features, got %d\n", COMBINED_FEATURES_SIZE, combined_features.size());
        return std::vector<float>(); // Return empty vector on error
    }

    std::vector<float> final_features(TFLITE_INPUT_SIZE);

    for (int i = 0; i < TFLITE_INPUT_SIZE; ++i) {
        int original_idx = SELECTED_FEATURE_INDICES[i];
        float value = combined_features[original_idx];
        float mean = NEW_FEATURE_SCALER_MEAN[original_idx];
        float std = NEW_FEATURE_SCALER_STD[original_idx];

        // Apply Z-score scaling
        if (std == 0.0f) {
            final_features[i] = 0.0f; // Avoid division by zero
        } else {
            final_features[i] = (value - mean) / std;
        }
    }

    return final_features;
}

// ============================================================================
// ARDUINO SETUP AND LOOP FUNCTIONS
// ============================================================================

// Human-readable labels and alert levels
const char* class_names[] = {"Normal", "Fall Detection", "Seizure", "Medical Emergency"};
const char* alert_levels[] = {"LOW", "HIGH", "CRITICAL", "CRITICAL"};

void setup() {
  Serial.begin(115200);
  while (!Serial && millis() < 5000); // Wait for serial port to connect. 5s timeout.
  Serial.println("\nMedical Wearable Health Monitoring System - ESP32 Inference\n");

  // Setup logging
  static tflite::MicroErrorReporter micro_error_reporter;
  error_reporter = &micro_error_reporter;
  tflite::MicroSystemSetup();

  // Map the model into a usable data structure.
  model = tflite::GetModel(medical_wearable_model_tflite);
  if (model->version() != TFLITE_SCHEMA_VERSION) {
    TF_LITE_REPORT_ERROR(error_reporter, "Model provided is schema version %d, but only version %d is supported (in setup())\n",
                         model->version(), TFLITE_SCHEMA_VERSION);
    return;
  }

  // This pulls in all the operation implementations we need.
  // This can be changed to MicroMutableOpResolver to save memory if you know the exact ops needed.
  static tflite::AllOpsResolver resolver;

  // Build an interpreter to run the model with.
  static tflite::MicroInterpreter static_interpreter(
      model, resolver, tensor_arena, kTensorArenaSize, error_reporter);
  interpreter = &static_interpreter;

  // Allocate tensors from the provided arena.
  TfLiteStatus allocate_status = interpreter->AllocateTensors();
  if (allocate_status != kTfLiteOk) {
    TF_LITE_REPORT_ERROR(error_reporter, "AllocateTensors() failed (in setup())\n");
    return;
  }

  // Obtain pointers to the model's input and output tensors.
  input_tensor = interpreter->input(0);
  output_tensor = interpreter->output(0);

  // Ensure the input tensor has the correct shape
  if (input_tensor->type != kTfLiteFloat32 || input_tensor->dims->size != 2 || input_tensor->dims->data[1] != TFLITE_INPUT_SIZE) {
    TF_LITE_REPORT_ERROR(error_reporter, "Bad input tensor shape or type. Expected float32 and shape [1, %d]. Got type %d, shape [%d, %d]\n",
                         TFLITE_INPUT_SIZE, input_tensor->type, input_tensor->dims->size > 1 ? input_tensor->dims->data[0] : 0, input_tensor->dims->size > 1 ? input_tensor->dims->data[1] : 0);
    return;
  }

  TF_LITE_REPORT_ERROR(error_reporter, "TFLite model loaded successfully! Input size: %d, Output size: %d, Arena size: %d bytes (used %d)\n",
                       input_tensor->dims->data[1], output_tensor->dims->data[1], kTensorArenaSize, interpreter->arena_used_bytes());
}

void loop() {
  // Simulate sensor data for different scenarios
  static int scenario_idx = 0;
  float raw_accel_x, raw_accel_y, raw_accel_z, raw_heart_rate, raw_temperature;

  switch (scenario_idx % 4) {
    case 0: // Normal Activity
      raw_accel_x = 0.3f; raw_accel_y = 0.2f; raw_accel_z = 9.8f;
      raw_heart_rate = 75.0f; raw_temperature = 36.8f;
      Serial.println("\n--- Simulating Normal Activity ---");
      break;
    case 1: // Fall Event
      raw_accel_x = -18.0f; raw_accel_y = 12.0f; raw_accel_z = -20.0f; // High impact acceleration
      raw_heart_rate = 85.0f; raw_temperature = 36.9f; // Slightly elevated HR, normal temp
      Serial.println("\n--- Simulating Fall Event ---");
      break;
    case 2: // Seizure Event
      raw_accel_x = 10.0f; raw_accel_y = -12.0f; raw_accel_z = 8.0f; // Violent, rapid movements
      raw_heart_rate = 135.0f; raw_temperature = 37.3f; // Tachycardia, slight temp elevation
      Serial.println("\n--- Simulating Seizure Event ---");
      break;
    case 3: // Medical Emergency (Fever)
      raw_accel_x = 0.1f; raw_accel_y = 0.1f; raw_accel_z = 9.8f; // Minimal movement
      raw_heart_rate = 122.0f; raw_temperature = 39.2f; // High fever, compensatory tachycardia
      Serial.println("\n--- Simulating Medical Emergency (Fever) ---");
      break;
  }
  scenario_idx++;

  Serial.printf("Inputs: Accel=(%.1f, %.1f, %.1f) m/s^2, HR=%.1f bpm, Temp=%.1f C\n",
                raw_accel_x, raw_accel_y, raw_accel_z, raw_heart_rate, raw_temperature);

  // 1. Feature Engineering
  std::vector<float> combined_features = create_medical_features_cpp(
      raw_accel_x, raw_accel_y, raw_accel_z, raw_heart_rate, raw_temperature);
  if (combined_features.empty()) {
      Serial.println("Error during feature engineering. Skipping inference.");
      delay(5000);
      return;
  }

  // 2. Final Scaling and Selection
  std::vector<float> final_features = apply_final_scaling_and_selection_cpp(combined_features);
  if (final_features.empty()) {
      Serial.println("Error during final scaling and selection. Skipping inference.");
      delay(5000);
      return;
  }

  // 3. Load TFLite Input
  for (int i = 0; i < TFLITE_INPUT_SIZE; ++i) {
    input_tensor->data.f[i] = final_features[i];
  }

  // 4. Run Inference
  TfLiteStatus invoke_status = interpreter->Invoke();
  if (invoke_status != kTfLiteOk) {
    TF_LITE_REPORT_ERROR(error_reporter, "Invoke failed on input (in loop())\n");
    return;
  }

  // 5. Get Output and Process Results
  float max_prob = 0.0f;
  int predicted_class_idx = -1;
  for (int i = 0; i < output_tensor->dims->data[1]; ++i) {
    float current_prob = output_tensor->data.f[i];
    // Serial.printf("  Prob[%d]: %.2f%%\n", i, current_prob * 100.0f);
    if (current_prob > max_prob) {
      max_prob = current_prob;
      predicted_class_idx = i;
    }
  }

  if (predicted_class_idx != -1) {
    Serial.println("Prediction:");
    Serial.printf("  Class: %s (ID: %d)\n", class_names[predicted_class_idx], predicted_class_idx);
    Serial.printf("  Confidence: %.2f%%\n", max_prob * 100.0f);
    Serial.printf("  Alert Level: %s\n", alert_levels[predicted_class_idx]);
  } else {
    Serial.println("Error: No prediction made.");
  }

  // Delay before next inference
  delay(5000);
}